-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create groups table
CREATE TABLE groups (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    color VARCHAR(7) NOT NULL, -- Hex color
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE,
    version INTEGER DEFAULT 1,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Create notes table
CREATE TABLE notes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL, -- Plain text content
    group_id UUID REFERENCES groups(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE,
    version INTEGER DEFAULT 1,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Create indexes for performance
CREATE INDEX idx_groups_user_id ON groups(user_id);
CREATE INDEX idx_groups_is_deleted ON groups(is_deleted);
CREATE INDEX idx_notes_user_id ON notes(user_id);
CREATE INDEX idx_notes_group_id ON notes(group_id);
CREATE INDEX idx_notes_is_deleted ON notes(is_deleted);
CREATE INDEX idx_notes_content ON notes USING gin(to_tsvector('english', content));

-- Enable Row Level Security
ALTER TABLE groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;

-- RLS Policies for groups
CREATE POLICY "Users can view their own groups" ON groups
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own groups" ON groups
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own groups" ON groups
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own groups" ON groups
    FOR DELETE USING (auth.uid() = user_id);

-- RLS Policies for notes
CREATE POLICY "Users can view their own notes" ON notes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own notes" ON notes
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own notes" ON notes
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own notes" ON notes
    FOR DELETE USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers to automatically update updated_at
CREATE TRIGGER update_groups_updated_at BEFORE UPDATE ON groups
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON notes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to seed default groups for new users
CREATE OR REPLACE FUNCTION seed_default_groups()
RETURNS TRIGGER AS $$
BEGIN
    -- Use security definer to bypass RLS for this function
    INSERT INTO groups (name, color, user_id) VALUES
        ('Work', '#14b8a6', NEW.id),
        ('Personal', '#0d9488', NEW.id),
        ('Ideas', '#0f766e', NEW.id),
        ('Tasks', '#115e59', NEW.id),
        ('Uncategorized', '#134e4a', NEW.id);
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Log the error but don't fail the user creation
        RAISE WARNING 'Failed to create default groups for user %: %', NEW.id, SQLERRM;
        RETURN NEW;
END;
$$ language 'plpgsql' SECURITY DEFINER;

-- Trigger to seed groups when user signs up
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION seed_default_groups();

-- Entity history for incremental change log
CREATE TABLE entity_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_table TEXT NOT NULL,
    entity_id UUID NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    operation TEXT NOT NULL,
    changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    data JSONB NOT NULL
);

CREATE INDEX idx_entity_history_entity ON entity_history (entity_table, entity_id, changed_at DESC);
CREATE INDEX idx_entity_history_user ON entity_history (user_id, changed_at DESC);
CREATE INDEX idx_entity_history_changed_at ON entity_history (changed_at);

ALTER TABLE entity_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own history" ON entity_history
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history" ON entity_history
    FOR INSERT WITH CHECK (auth.uid() = user_id);

GRANT SELECT, INSERT ON entity_history TO authenticated;

-- Function to log changes for notes and groups
CREATE OR REPLACE FUNCTION log_entity_history()
RETURNS TRIGGER AS $$
DECLARE
    actor_id UUID;
BEGIN
    IF (TG_OP = 'DELETE') THEN
        actor_id := COALESCE(auth.uid(), OLD.user_id);
        INSERT INTO entity_history (entity_table, entity_id, user_id, operation, data)
        VALUES (TG_TABLE_NAME, OLD.id, actor_id, LOWER(TG_OP), TO_JSONB(OLD));
        RETURN OLD;
    ELSE
        actor_id := COALESCE(auth.uid(), NEW.user_id);
        INSERT INTO entity_history (entity_table, entity_id, user_id, operation, data)
        VALUES (TG_TABLE_NAME, NEW.id, actor_id, LOWER(TG_OP), TO_JSONB(NEW));
        RETURN NEW;
    END IF;
END;
$$ language 'plpgsql' SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION restore_note_history(UUID, BIGINT) TO authenticated;

CREATE TRIGGER notes_history_trigger
    AFTER INSERT OR UPDATE OR DELETE ON notes
    FOR EACH ROW EXECUTE FUNCTION log_entity_history();

CREATE TRIGGER groups_history_trigger
    AFTER INSERT OR UPDATE OR DELETE ON groups
    FOR EACH ROW EXECUTE FUNCTION log_entity_history();

-- Restore note history with conditional pruning
CREATE OR REPLACE FUNCTION restore_note_history(note_id UUID, history_id BIGINT)
RETURNS JSONB AS $$
DECLARE
    history_row entity_history%ROWTYPE;
    current_row notes%ROWTYPE;
    target_data JSONB;
    target_group_id UUID;
    uncategorized_id UUID;
    applied BOOLEAN;
BEGIN
    SELECT * INTO history_row
    FROM entity_history
    WHERE id = history_id
      AND entity_table = 'notes'
      AND entity_id = note_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'History entry not found';
    END IF;

    IF history_row.user_id IS DISTINCT FROM auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;

    SELECT * INTO current_row
    FROM notes
    WHERE id = note_id
      AND user_id = auth.uid();

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Note not found';
    END IF;

    target_data := history_row.data;

    IF target_data ? 'group_id' AND NULLIF(target_data->>'group_id', '') IS NOT NULL THEN
        target_group_id := (target_data->>'group_id')::UUID;
    ELSE
        target_group_id := NULL;
    END IF;

    IF target_group_id IS NULL
       OR NOT EXISTS (
           SELECT 1 FROM groups
           WHERE id = target_group_id
             AND user_id = auth.uid()
             AND is_deleted = FALSE
       ) THEN
        SELECT id INTO uncategorized_id
        FROM groups
        WHERE user_id = auth.uid()
          AND name = 'Uncategorized'
        ORDER BY is_deleted ASC
        LIMIT 1;

        IF uncategorized_id IS NULL THEN
            INSERT INTO groups (name, color, user_id)
            VALUES ('Uncategorized', '#134e4a', auth.uid())
            RETURNING id INTO uncategorized_id;
        ELSE
            UPDATE groups
            SET is_deleted = FALSE
            WHERE id = uncategorized_id;
        END IF;

        target_group_id := uncategorized_id;
    END IF;

    applied := (current_row.title IS DISTINCT FROM COALESCE(target_data->>'title', current_row.title))
        OR (current_row.content IS DISTINCT FROM COALESCE(target_data->>'content', current_row.content))
        OR (current_row.group_id IS DISTINCT FROM target_group_id)
        OR (current_row.is_deleted IS DISTINCT FROM FALSE);

    IF NOT applied THEN
        RETURN JSONB_BUILD_OBJECT('applied', FALSE, 'note', TO_JSONB(current_row));
    END IF;

    DELETE FROM entity_history
    WHERE entity_table = 'notes'
      AND entity_id = note_id
      AND changed_at > history_row.changed_at;

    UPDATE notes
    SET title = COALESCE(target_data->>'title', current_row.title),
        content = COALESCE(target_data->>'content', current_row.content),
        group_id = target_group_id,
        is_deleted = FALSE
    WHERE id = note_id;

    SELECT * INTO current_row FROM notes WHERE id = note_id;

    RETURN JSONB_BUILD_OBJECT('applied', TRUE, 'note', TO_JSONB(current_row));
END;
$$ language 'plpgsql' SECURITY DEFINER SET search_path = public;

-- Retention cleanup function (7 days)
CREATE OR REPLACE FUNCTION prune_entity_history()
RETURNS void AS $$
    DELETE FROM entity_history
    WHERE changed_at < NOW() - INTERVAL '7 days';
$$ language 'sql' SECURITY DEFINER SET search_path = public;

-- Optional: schedule cleanup hourly (requires pg_cron extension)
CREATE EXTENSION IF NOT EXISTS pg_cron;
-- SELECT cron.schedule('prune-entity-history', '0 * * * *', 'SELECT prune_entity_history();');
