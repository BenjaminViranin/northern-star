-- History table for incremental change log
CREATE TABLE IF NOT EXISTS entity_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_table TEXT NOT NULL,
    entity_id UUID NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    operation TEXT NOT NULL,
    changed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    data JSONB NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_entity_history_entity
    ON entity_history (entity_table, entity_id, changed_at DESC);
CREATE INDEX IF NOT EXISTS idx_entity_history_user
    ON entity_history (user_id, changed_at DESC);
CREATE INDEX IF NOT EXISTS idx_entity_history_changed_at
    ON entity_history (changed_at);

ALTER TABLE entity_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own history"
    ON entity_history
    FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own history"
    ON entity_history
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

GRANT SELECT, INSERT ON entity_history TO authenticated;

-- Trigger function to log changes for notes and groups
CREATE OR REPLACE FUNCTION log_entity_history()
RETURNS TRIGGER AS $$
DECLARE
    actor_id UUID;
BEGIN
    IF (TG_OP = 'DELETE') THEN
        actor_id := COALESCE(auth.uid(), OLD.user_id);
        INSERT INTO entity_history (entity_table, entity_id, user_id, operation, data)
        VALUES (TG_TABLE_NAME, OLD.id, actor_id, LOWER(TG_OP), TO_JSONB(OLD));
        RETURN OLD;
    ELSE
        actor_id := COALESCE(auth.uid(), NEW.user_id);
        INSERT INTO entity_history (entity_table, entity_id, user_id, operation, data)
        VALUES (TG_TABLE_NAME, NEW.id, actor_id, LOWER(TG_OP), TO_JSONB(NEW));
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

DROP TRIGGER IF EXISTS notes_history_trigger ON notes;
CREATE TRIGGER notes_history_trigger
    AFTER INSERT OR UPDATE OR DELETE ON notes
    FOR EACH ROW EXECUTE FUNCTION log_entity_history();

DROP TRIGGER IF EXISTS groups_history_trigger ON groups;
CREATE TRIGGER groups_history_trigger
    AFTER INSERT OR UPDATE OR DELETE ON groups
    FOR EACH ROW EXECUTE FUNCTION log_entity_history();

-- Restore note history with conditional pruning
CREATE OR REPLACE FUNCTION restore_note_history(note_id UUID, history_id BIGINT)
RETURNS JSONB AS $$
DECLARE
    history_row entity_history%ROWTYPE;
    current_row notes%ROWTYPE;
    target_data JSONB;
    target_group_id UUID;
    uncategorized_id UUID;
    applied BOOLEAN;
BEGIN
    SELECT * INTO history_row
    FROM entity_history
    WHERE id = history_id
      AND entity_table = 'notes'
      AND entity_id = note_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'History entry not found';
    END IF;

    IF history_row.user_id IS DISTINCT FROM auth.uid() THEN
        RAISE EXCEPTION 'Unauthorized';
    END IF;

    SELECT * INTO current_row
    FROM notes
    WHERE id = note_id
      AND user_id = auth.uid();

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Note not found';
    END IF;

    target_data := history_row.data;

    IF target_data ? 'group_id' AND NULLIF(target_data->>'group_id', '') IS NOT NULL THEN
        target_group_id := (target_data->>'group_id')::UUID;
    ELSE
        target_group_id := NULL;
    END IF;

    IF target_group_id IS NULL
       OR NOT EXISTS (
           SELECT 1 FROM groups
           WHERE id = target_group_id
             AND user_id = auth.uid()
             AND is_deleted = FALSE
       ) THEN
        SELECT id INTO uncategorized_id
        FROM groups
        WHERE user_id = auth.uid()
          AND name = 'Uncategorized'
        ORDER BY is_deleted ASC
        LIMIT 1;

        IF uncategorized_id IS NULL THEN
            INSERT INTO groups (name, color, user_id)
            VALUES ('Uncategorized', '#134e4a', auth.uid())
            RETURNING id INTO uncategorized_id;
        ELSE
            UPDATE groups
            SET is_deleted = FALSE
            WHERE id = uncategorized_id;
        END IF;

        target_group_id := uncategorized_id;
    END IF;

    applied := (current_row.title IS DISTINCT FROM COALESCE(target_data->>'title', current_row.title))
        OR (current_row.content IS DISTINCT FROM COALESCE(target_data->>'content', current_row.content))
        OR (current_row.group_id IS DISTINCT FROM target_group_id)
        OR (current_row.is_deleted IS DISTINCT FROM FALSE);

    IF NOT applied THEN
        RETURN JSONB_BUILD_OBJECT('applied', FALSE, 'note', TO_JSONB(current_row));
    END IF;

    DELETE FROM entity_history
    WHERE entity_table = 'notes'
      AND entity_id = note_id
      AND changed_at > history_row.changed_at;

    UPDATE notes
    SET title = COALESCE(target_data->>'title', current_row.title),
        content = COALESCE(target_data->>'content', current_row.content),
        group_id = target_group_id,
        is_deleted = FALSE
    WHERE id = note_id;

    SELECT * INTO current_row FROM notes WHERE id = note_id;

    RETURN JSONB_BUILD_OBJECT('applied', TRUE, 'note', TO_JSONB(current_row));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

GRANT EXECUTE ON FUNCTION restore_note_history(UUID, BIGINT) TO authenticated;

-- Retention cleanup function (7 days)
CREATE OR REPLACE FUNCTION prune_entity_history()
RETURNS VOID AS $$
    DELETE FROM entity_history
    WHERE changed_at < NOW() - INTERVAL '7 days';
$$ LANGUAGE sql SECURITY DEFINER SET search_path = public;

-- Schedule cleanup hourly (requires pg_cron)
CREATE EXTENSION IF NOT EXISTS pg_cron;
SELECT cron.schedule(
    'prune-entity-history',
    '0 * * * *',
    $$SELECT public.prune_entity_history();$$
);
